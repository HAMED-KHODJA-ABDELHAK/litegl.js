<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>../src/shader.js</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="../assets/css/logo.png" title=""></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: </em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="../classes/BBox.html">BBox</a></li>
            
                <li><a href="../classes/Buffer.html">Buffer</a></li>
            
                <li><a href="../classes/geo.html">geo</a></li>
            
                <li><a href="../classes/GL.html">GL</a></li>
            
                <li><a href="../classes/Indexer.html">Indexer</a></li>
            
                <li><a href="../classes/LEvent.html">LEvent</a></li>
            
                <li><a href="../classes/Mesh.html">Mesh</a></li>
            
                <li><a href="../classes/Octree.html">Octree</a></li>
            
                <li><a href="../classes/Shader.html">Shader</a></li>
            
                <li><a href="../classes/Texture.html">Texture</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: ../src/shader.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
/**
* Shader class to upload programs to the GPU
* @class Shader
* @constructor
* @param {String} vertexSource
* @param {String} fragmentSource
* @param {Object} macros (optional) precompiler macros to be applied when compiling
*/
function Shader(vertexSource, fragmentSource, macros)
{
	var extra_code = &quot;&quot;;
	//expand macros
	if(macros)
		for(var i in macros)
			extra_code += &quot;#define &quot; + i + &quot; &quot; + (macros[i] ? macros[i] : &quot;&quot;) + &quot;\n&quot;;

	//Compile shader
	function compileSource(type, source) {
		var shader = gl.createShader(type);
		gl.shaderSource(shader, source);
		gl.compileShader(shader);
		if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
			throw (type == gl.VERTEX_SHADER ? &quot;Vertex&quot; : &quot;Fragment&quot;) + &#x27; shader compile error: &#x27; + gl.getShaderInfoLog(shader);
		}
		return shader;
	}

	this.program = gl.createProgram();
	gl.attachShader(this.program, compileSource(gl.VERTEX_SHADER, extra_code + vertexSource));
	gl.attachShader(this.program, compileSource(gl.FRAGMENT_SHADER, extra_code + fragmentSource));
	gl.linkProgram(this.program);
	if (!gl.getProgramParameter(this.program, gl.LINK_STATUS)) {
		throw &#x27;link error: &#x27; + gl.getProgramInfoLog(this.program);
	}

	//Extract info from the shader
	this.attributes = {}; 
	this.uniformInfo = {};
	this.samplers = {};
	/* old version, search samplers using regexMap as done by lightGL, now I query the shader directly
	var samplers = this.samplers;
	regexMap(/uniform\s+sampler(1D|2D|3D|Cube)\s+(\w+)\s*;/g, vertexSource + fragmentSource, function(groups) {
		samplers[groups[2]] = 1;
	});
	*/

	//extract uniform and attribs locations to speed up future processes
	for(var i = 0, l = gl.getProgramParameter(this.program, gl.ACTIVE_UNIFORMS); i &lt; l; ++i)
	{
		var data = gl.getActiveUniform( this.program, i);
		if(!data) break;

		var uniformName = data.name;

		//arrays have uniformName[0], strip the [] (also data.size tells you if it is an array)
		var pos = uniformName.indexOf(&quot;[&quot;); 
		if(pos != -1)
			uniformName = uniformName.substr(0,pos);

		//store texture samplers
		if(data.type == gl.SAMPLER_2D || data.type == gl.SAMPLER_CUBE)
			this.samplers[ uniformName ] = data.type;
		
		//get which function to call when uploading this uniform
		var func = Shader.getUniformFunc(data);
		var is_matrix = false;
		if(data.type == gl.FLOAT_MAT2 || data.type == gl.FLOAT_MAT3 || data.type == gl.FLOAT_MAT4)
			is_matrix = true;


		//save the info so I the user doesnt have to specify types when uploading data to the shader
		this.uniformInfo[ uniformName ] = { type: data.type, func: func, size: data.size, is_matrix: is_matrix, loc: gl.getUniformLocation(this.program, uniformName) };
	}

	for(var i = 0, l = gl.getProgramParameter(this.program, gl.ACTIVE_ATTRIBUTES); i &lt; l; ++i)
	{
		var data = gl.getActiveAttrib( this.program, i);
		if(!data) break;
		var func = Shader.getUniformFunc(data);
		//this.uniformInfo[ data.name ] = { type: data.gl.getUniformLocation(this.program, data.name) };
		this.uniformInfo[ data.name ] = { type: data.type, func: func, size: data.size, loc: gl.getUniformLocation(this.program, data.name ) };
		this.attributes[ data.name ] = gl.getAttribLocation(this.program, data.name );	
	}
}

//Tells you which function to call when uploading a uniform according to the data type in the shader
Shader.getUniformFunc = function( data )
{
	var func = null;
	switch (data.type)
	{
		case gl.FLOAT: 		
			if(data.size == 1)
				func = gl.uniform1f; 
			else
				func = gl.uniform1fv; 
			break;
		case gl.FLOAT_MAT2: func = gl.uniformMatrix2fv; break;
		case gl.FLOAT_MAT3:	func = gl.uniformMatrix3fv; break;
		case gl.FLOAT_MAT4:	func = gl.uniformMatrix4fv; break;
		case gl.FLOAT_VEC2: func = gl.uniform2fv; break;
		case gl.FLOAT_VEC3: func = gl.uniform3fv; break;
		case gl.FLOAT_VEC4: func = gl.uniform4fv; break;

		case gl.UNSIGNED_INT: 
		case gl.INT: 	  
			if(data.size == 1)
				func = gl.uniform1i; 
			else
				func = gl.uniform1iv; 
			break;
		case gl.INT_VEC2: func = gl.uniform2iv; break;
		case gl.INT_VEC3: func = gl.uniform3iv; break;
		case gl.INT_VEC4: func = gl.uniform4iv; break;

		case gl.SAMPLER_2D:
		case gl.SAMPLER_CUBE:
			func = gl.uniform1i; break;
		default: func = gl.uniform1f; break;
	}	
	return func;
}

/* TODO, I dont like the idea of creating a shader which is not complete till files are retrieved
Shader.fromFiles = function( vs_path, ps_path )
{
	var vs_code = null;
	var fs_code = null;
	
}
*/

/**
* Uploads a set of uniforms to the Shader
* @method uniforms
* @param {Object} uniforms
*/

Shader._temp_uniform = new Float32Array(16);

Shader.prototype.uniforms = function(uniforms) {

	gl.useProgram(this.program);
	//var last_slot = 0;

	for (var name in uniforms) {
		var info = this.uniformInfo[name];
		if (!info) continue;

		var value = uniforms[name];
		if(value == null) continue;

		if(value.constructor === Array)
			value = new Float32Array(value);  //garbage...

		if(info.is_matrix)
			info.func.call( gl, info.loc, false, value );
		else
			info.func.call( gl, info.loc, value );
	}
	return this;
}//uniforms

/*
Shader.prototype.uniforms_OLD = function(uniforms) {

	gl.useProgram(this.program);
	//var last_slot = 0;

	for (var name in uniforms) {
		var info = this.uniformInfo[name];
		if (!info) continue;
		var location = info.loc;

		var value = uniforms[name];
		if(value == null) continue;
		if(value.constructor == Float32Array)
		{
			switch (value.length) {
				case 1: gl.uniform1fv(location, value); break; //float
				case 2: gl.uniform2fv(location, value); break; //vec2
				case 3: gl.uniform3fv(location, value); break; //vec3
				case 4: gl.uniform4fv(location, value); break; //vec4
				case 9: gl.uniformMatrix3fv(location, false,  value); break; //matrix3
				case 16: gl.uniformMatrix4fv(location, false, value); break; //matrix4
				default: 
					var data = gl.getActiveAttrib( this.program, name );
					if(value.length % 16 == 0) //HACK for bones
						gl.uniformMatrix4fv(location, false, value ); //mat4
					else
						gl.uniform1fv(location, value); 
					break; //n float
				//default: throw &#x27;don\&#x27;t know how to load uniform &quot;&#x27; + name + &#x27;&quot; of length &#x27; + value.length;
			}
		} 
		else if (isArray(value)) //non-typed arrays
		{
			switch (value.length) {
			case 1: gl.uniform1f(location, value); break; //float
			case 2: gl.uniform2f(location, value[0], value[1] ); break; //vec2
			case 3: gl.uniform3f(location, value[0], value[1], value[2] ); break; //vec3
			case 4: gl.uniform4f(location, value[0], value[1], value[2], value[3] ); break; //vec4
			case 9: Shader._temp_uniform.set( value ); gl.uniformMatrix3fv(location, false, Shader._temp_uniform ); break; //mat3
			case 16: Shader._temp_uniform.set( value ); gl.uniformMatrix4fv(location, false, Shader._temp_uniform ); break; //mat4
			default: 
				Shader._temp_uniform.set( value ); 
				if(value.length % 16 == 0)
					gl.uniformMatrix4fv(location, false, Shader._temp_uniform ); //mat4
				else
					gl.uniform1fv(location, Shader._temp_uniform); 
				break; //n float
			//default: throw &#x27;don\&#x27;t know how to load uniform &quot;&#x27; + name + &#x27;&quot; of length &#x27; + value.length;
			}
		}
		else if (isNumber(value))
		{
			(this.samplers[name] ? gl.uniform1i : gl.uniform1f).call(gl, location, value);
		} else {
			throw &#x27;attempted to set uniform &quot;&#x27; + name + &#x27;&quot; to invalid value &#x27; + value;
		}
	}
	return this;
}//uniforms
*/

/**
* Renders a mesh using this shader, remember to use the function uniforms before to enable the shader
* @method draw
* @param {Mesh} mesh
* @param {number} mode could be gl.LINES, gl.POINTS, gl.TRIANGLES, gl.TRIANGLE_STRIP, gl.TRIANGLE_FAN
*/
Shader.prototype.draw = function(mesh, mode) {
	this.drawBuffers(mesh.vertexBuffers,
	  mesh.indexBuffers[mode == gl.LINES ? &#x27;lines&#x27; : &#x27;triangles&#x27;],
	  arguments.length &lt; 2 ? gl.TRIANGLES : mode);
}

/**
* Renders a range of a mesh using this shader
* @method drawRange
* @param {Mesh} mesh
* @param {number} mode could be gl.LINES, gl.POINTS, gl.TRIANGLES, gl.TRIANGLE_STRIP, gl.TRIANGLE_FAN
* @param {number} start first primitive to render
* @param {number} length number of primitives to render
*/
Shader.prototype.drawRange = function(mesh, mode, start, length)
{
	this.drawBuffers(mesh.vertexBuffers,
	  mesh.indexBuffers[mode == gl.LINES ? &#x27;lines&#x27; : &#x27;triangles&#x27;],
	  mode, start, length);
}

/**
* Renders a range of a mesh using this shader
* @method drawBuffers
* @param {Object} vertexBuffers an object containing all the buffers
* @param {IndexBuffer} indexBuffer
* @param {number} mode could be gl.LINES, gl.POINTS, gl.TRIANGLES, gl.TRIANGLE_STRIP, gl.TRIANGLE_FAN
* @param {number} range_start first primitive to render
* @param {number} range_length number of primitives to render
*/

//this two variables are a hack to avoid memory allocation on drawCalls
Shader._temp_attribs_array = new Uint8Array(16);
Shader._temp_attribs_array_zero = new Uint8Array(16); //should be filled with zeros always

Shader.prototype.drawBuffers = function(vertexBuffers, indexBuffer, mode, range_start, range_length)
{
	if(range_length == 0) return;

	// enable attributes as necessary.
	var length = 0;
	var attribs_in_use = Shader._temp_attribs_array; //hack to avoid garbage
	attribs_in_use.set( Shader._temp_attribs_array_zero ); //reset

	for (var name in vertexBuffers)
	{
		var buffer = vertexBuffers[name];
		var attribute = buffer.attribute || name;
		//precompute attribute locations in shader
		var location = this.attributes[attribute];// || gl.getAttribLocation(this.program, attribute);

		if (location == null || !buffer.buffer) //-1 changed for null
			continue; //ignore this buffer

		attribs_in_use[location] = 1; //mark it as used

		//this.attributes[attribute] = location;
		gl.bindBuffer(gl.ARRAY_BUFFER, buffer.buffer);
		gl.enableVertexAttribArray(location);

		gl.vertexAttribPointer(location, buffer.buffer.spacing, buffer.buffer.gl_type, false, 0, 0);
		length = buffer.buffer.length / buffer.buffer.spacing;
	}

	//range rendering
	var offset = 0;
	if(range_start &gt; 0) //render a polygon range
		offset = range_start * (indexBuffer ? indexBuffer.constructor.BYTES_PER_ELEMENT : 1); //in bytes (Uint16 == 2 bytes)

	if(range_length &gt; 0)
		length = range_length;
	else if (indexBuffer)
		length = indexBuffer.buffer.length - offset;

	// Force to disable buffers in this shader that are not in this mesh
	for (var attribute in this.attributes)
	{
		var location = this.attributes[attribute];
		if (!(attribs_in_use[location])) {
			gl.disableVertexAttribArray(this.attributes[attribute]);
		}
	}

	// Draw the geometry.
	if (length &amp;&amp; (!indexBuffer || indexBuffer.buffer)) {
	  if (indexBuffer) {
		gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer.buffer);
		gl.drawElements(mode, length, gl.UNSIGNED_SHORT, offset);
		gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
	  } else {
		gl.drawArrays(mode, offset, length);
	  }
	}

	return this;
}


//Now some common shaders everybody needs

//Screen shader: used to render one texture into another
Shader.getScreenShader = function()
{
	if(gl._screen_shader)
		return gl._screen_shader;

	var shader = new GL.Shader(&quot;\n\
			precision highp float;\n\
			attribute vec3 a_vertex;\n\
			attribute vec2 a_coord;\n\
			varying vec2 coord;\n\
			void main() { \n\
				coord = a_coord; \n\
				gl_Position = vec4(coord * 2.0 - 1.0, 0.0, 1.0); \n\
			}\n\
			&quot;,&quot;\n\
			precision highp float;\n\
			uniform sampler2D texture;\n\
			varying vec2 coord;\n\
			void main() {\n\
				gl_FragColor = texture2D(texture, coord);\n\
			}\n\
			&quot;);
	gl._screen_shader = shader;
	return gl._screen_shader;
}

//Blur shader
Shader.getBlurShader = function()
{
	if(gl._blur_shader)
		return gl._blur_shader;

	var shader = new GL.Shader(&quot;\n\
			precision highp float;\n\
			attribute vec3 a_vertex;\n\
			attribute vec2 a_coord;\n\
			varying vec2 v_coord;\n\
			void main() {\n\
				v_coord = a_coord; gl_Position = vec4(v_coord * 2.0 - 1.0, 0.0, 1.0);\n\
			}\n\
			&quot;,&quot;\n\
			precision highp float;\n\
			varying vec2 v_coord;\n\
			uniform sampler2D u_texture;\n\
			uniform vec2 u_offset;\n\
			uniform float u_intensity;\n\
			void main() {\n\
			   vec4 sum = vec4(0.0);\n\
			   sum += texture2D(u_texture, v_coord + u_offset * -4.0) * 0.05/0.98;\n\
			   sum += texture2D(u_texture, v_coord + u_offset * -3.0) * 0.09/0.98;\n\
			   sum += texture2D(u_texture, v_coord + u_offset * -2.0) * 0.12/0.98;\n\
			   sum += texture2D(u_texture, v_coord + u_offset * -1.0) * 0.15/0.98;\n\
			   sum += texture2D(u_texture, v_coord) * 0.16/0.98;\n\
			   sum += texture2D(u_texture, v_coord + u_offset * 4.0) * 0.05/0.98;\n\
			   sum += texture2D(u_texture, v_coord + u_offset * 3.0) * 0.09/0.98;\n\
			   sum += texture2D(u_texture, v_coord + u_offset * 2.0) * 0.12/0.98;\n\
			   sum += texture2D(u_texture, v_coord + u_offset * 1.0) * 0.15/0.98;\n\
			   gl_FragColor = u_intensity * sum;\n\
			}\n\
			&quot;);
	gl._blur_shader = shader;
	return gl._blur_shader;
}
    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
